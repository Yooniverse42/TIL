# 타입스크립트 이해하기

## 타입은 집합이다

만약 number Type 이라면 어떤 숫자든 가능하다.  
하지만 number Literal Type이라면?

```tsx
let num: 20 = 20;
```

number Type의 부분집합이 되는 것.  
이럴 때 number Type을 슈퍼타입(부모타입)이라 하고 number literal Type을 서브타입(자식타입)이라고 한다.

서브타입을 슈퍼타입에게 대입시키는 것을 업 캐스팅(Up Cast)라 하고 슈퍼타입을 서브타입에게 대입하는 것을 다운 캐스팅(Down Cast)라 한다.

```tsx
let num1: number = 10;
let num2: 10 = 10;

// 업 캐스팅(가능)
num1 = num2;

// 다운 캐스팅 (불가능)
// 왜냐하면 number Type이기 때문에 현재는 10이지만 나중에는 어떠한 숫자가 들어올지 모른다.
num2 = num1; // 에러
```

### 타입 계층도

![image.png](./images/ts03-image1.png)

<small>출처 : 한 입 크기로 잘라먹는 타입스크립트</small>

<br>
<br>

## 객체 타입의 호환성

어떤 객체타입을 다른 객체타입으로 취급해도 괜찮은가?

```tsx
type Animal = {
  name: string;
  color: string;
};

type Dog = {
  name: string;
  color: string;
  bread: string;
};

let animal: Animal = {
  name: "기린",
  color: "yellow",
};

let dog: Dog = {
  name: "돌돌이",
  color: "brown",
  bread: "진도",
};

animal = dog;
dog = animal; // 에러
```

여기선 Animal이 슈퍼타입, Dog는 서브타입이 됨.  
하지만 아래처럼 하면 안됨.

```tsx
let dog2: Animal = {
  name: "댕댕이",
  color: "white",
  bread: "시츄",
};
```

`animal = dog` 는 되고, `let dog2: Animal` 은 안된다?

이유는 초과 프로퍼티를 검사하기 때문임.  
초과 프로퍼티 검사 = 실제로 정의하지 않은 프로퍼티를 작성하지 못하도록 막는 검사  
그래도 breed를 사용하고 싶다면?

```tsx
let dog2: Animal = dog;
```

변수를 전달해야 한다. 함수도 마찬가지

```tsx
function func(dog: Animal) {}

func({
  name: "댕댕이",
  color: "white",
  // bread: "시츄",
});

// 그래서 변수로 전달해야함
func(dog2);
```

<br>
<br>

## 대수 타입

여러 개의 타입을 합성해서 새롭게 만들어낸 타입.  
합집합 타입과 교집합 타입이 존재한다.

### 합집합 - Union Type

```tsx
// 합집합 - Union 타입
let a: string | number;
a = 1;
a = "hello";
```

타입은 무한으로 추가할 수 있다.

```tsx
let a: string | number | boolean | undefined | null | {};
```

배열에서도 사용 가능하다.

```tsx
let arr: (number | string | boolean)[] = [1, "hello", true];
```

객체에서도 사용 가능하다.

```tsx
type Dog = {
  name: string;
  color: string;
};

type Person = {
  name: string;
  language: string;
};

// Union 타입인 새로운 타입 변수 만들어 줌
type Union1 = Dog | Person;

// 새로운 타입을 사용
let union1: Union1 = {
  name: "",
  color: "",
};

let union2: Union1 = {
  name: "",
  language: "",
};

// 모든 속성을 사용해도 에러가 나지 않음
let union3: Union1 = {
  name: "",
  color: "",
  language: "",
};

// 하지만 하나의 속성만 사용하면 에러가 남
// let union4: Union1 = {
//   name: "",
// };
```

union4가 에러가 나는 이유를 알아보자.

![image.png](./images/ts03-image2.png)

속성으로 보는 것이 아닌 타입 전체를 확인해야 한다.

union4가 name 속성만 있다해서 교집합에 포함되는 것이 아니라, color타입이 없어 Dog Type도 아니고 language타입이 없어 Person Type도 아니게 되어 어떤 타입에도 포함이 되지 않는 것이다.

### 교집합 - Intersection Type

```tsx
let variable: number & string;
```

number와 string은 겹치는 것이 없기 때문제 공집합으로 볼 수 있다.  
그래서 교집합은 보통 `never` 타입이다.  
그래서 객체 타입에 자주 사용한다.  
위의 Dog와 Person 타입을 한 번더 이용해보자.

```tsx
type Intersection = Dog & Person;

let intersection1: Intersection = {
  name: "",
  color: "",
  language: "",
};
```

만약 intersection1에서 속성이 하나라도 빠지게 되면 에러가 난다.

왜냐하면 `Intersection` 타입은 모든 속성을 갖는 union3같은 교집합을 만들어낸 것이기 때문이다.

<br>
<br>

## 타입 추론

타입스크립트는 타입을 따로 지정하지 않아도 추론해주는데, 추론해주는 기준은 변수의 초기값이다.

함수의 반환값은 그 반환값을 기준으로 추론한다. 매개변수는 만약 기본값이 설정되어 있다면, 기본값을 기준으로 추론한다.

```tsx
let a = 10;
let b = "hello";

let c = {
  id: 1,
  name: "yooni",
  profile: {
    nickname: "yooooon",
  },
  urls: ["https://yooniverse42.com"],
};

// 구조 분해 할당에서도 추론이 잘 된다.
let { id, name, profile } = c;

let [one, two, three] = [1, "hello", true];

// 함수
function func(message = "hello") {
  return "hello";
}
```

하지만 생각과 다르게 추론 될 때도 있다.

```tsx
let d; // (1)
d = 10; // (2)
d.toFixed(); // (3)
// d.toUpperCase(); // 에러
```

(1)에서는 any타입으로 잡히지만 (2)에서 숫자를 대입함으로서 number타입으로 변경이 된다. 그래서 (3)과 같이 number타입에서 사용 가능한 메서드는 에러가 나지 않지만, 문자열 메서드를 사용하면 에러가 난다.

하지만 d에 문자열을 대입하면 다시 문자열로 변경이 된다.

```tsx
let d;
d = 10;
d.toFixed();

d = "hello"; // 문자열 타입으로 변경된다.
d.toUpperCase(); // 에러가 나지 않는다.
// d.toFixed(); // 에러
```

이런 상황을 any타입의 진화하고 한다.  
만약 let이 아닌 const라면?

```tsx
const num = 10;
const str = "hello";
```

const는 상수여서 값이 변하지 않는다. 그래서 따로 number타입이나 string타입으로 지정이 되는게 아니라 리터럴 타입으로 지정이 된다.
