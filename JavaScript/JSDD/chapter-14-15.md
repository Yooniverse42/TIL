# 14장. 전역 변수의 문제점

## 14.1 변수의 생명 주기

변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. + 소멸  
= 생명 주기

- 전역 변수의 생명 주기 = 애플리케이션의 생명 주기
- 지역 변수의 생명 주기 = 함수 종료와 동시에 소멸

but, 함수 몸체보다 지역 변수가 오래 생존하는 경우도 있음. 그 지역을 누군가가 계속 **참조**하고 있다면 해제되지 않음. 스코프도 마찬가지임.

```jsx
var x = "global";

function foo() {
  console.log(x); // undefined => 호이스팅으로 인해 var x;가 먼저 동작해서 언디파인드나옴.
  var x = "local";
}

foo();
console.log(x); // 전역 변수 x를 가리킴.
```

## 14.2 전역 변수의 문제점

그래서 전역 변수의 문제점은 무엇인가?

### 1. 암묵적 결합

전역 변수를 선언한 의도는 코드 어디서든 참조하고 할당하기 위함. 즉, 암묵적 결합이라는 것을 허용한다는 것.  
하지만 변수의 유효 범위가 클수록 가독성 bad + 의도치 않게 상태 변경될 위험성 up

### 2. 긴 생명 주기

유효 범위가 크다? = 생명 주기가 길다. = 메모리 리소스도 오랜 기간 소비한다.  
그리고 var 키워드는 중복 선언 허용.. 결국 변수 이름 중복 가능성 O, 의도치 않은 재할당 O  
그래서 이유가 없다면 지역 변수를 사용하도록!

### 3. 스코프 체인 상에서 종점에 존재

= 변수를 검색할 때 전역 변수가 가장 마지막에 검색됨. = 검색 속도 가장 느림

> 💡질문) 왜 마지막에 검색되는거지..? 스코프 체인 상 가장 위 아님?

### 4. 네임스페이스 오염

가장 큰 문제점 중 하나! 파일이 분리되어 있다 해도, 하나의 전역 스코프를 공유함! 그래서 다른 파일에서 동일한 이름의 변수 or 전역 함수가 존재할 가능성 있음. = 예상치 못한 결과..

## 14.3 전역 변수의 사용을 억제하는 방법

### 1. 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다!

📌  p.177 참고) 즉시 실행 함수란? 함수 정의와 동시에 즉시 호출되는 함수! 단 한 번만 호출되며 재호출 불가!

### 2. 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법?!

```jsx
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = "Lee";

console.log(MYAPP.name); // Lee
```

> 음… 내가 보기엔 이것도 전역 변수 아닌가.. 책에서도 그다지 유용해 보이지 않는다고 한다!ㅋㅋ

### 3. 모듈 패턴

모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싼다.. 그래서 하나의 모듈을 만든다?! 모듈 패턴을 이해하려면 클로저를 알아야 한다고 하니 24장 클로저를 살펴보고 다시 확인해보자~

캡슐화 = 프로퍼티 + 메서드

객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 함 = 정보 은닉

```jsx
var Counter = (function () {
  // private 변수.. 외부에서 접근 못함.
  var num = 0;

  // 객체 반환 = public 멤버 = 외부에서 접근 가능
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    },
  };
})();

console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

> 음..그러니까.. 즉시 실행 함수는 재호출이 되지 않지만.. var 키워드를 이용해서 즉시 실행함수를 값으로 만들고! return에 함수를 넣으면, 그 함수를 부르면 호출이 된다..?! 다만 프라이빗 멤버는 접근이 안되서 undefined로 나온다..라는 말인가보다..!ㅎㅎㅎ

### ES6 모듈

얘는 파일 자체의 독자적인 모듈 스코프를 제공해서 전역 변수를 사용할 수 없다!  
사용 방법은 script 태그에 `type="module"` 어트리뷰트를 추가! 확장자는 mjs를 권장

```html
<script type="module" src="app.mjs"></script>
```

IE 이 자슥이 또 지원을 안하네..?ㅎ; 그리고 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링 이라는 것이 필요하다고 한다.. 그래서 `Webpack` 등의 모듈 번들러를 사용하는 것이 일반적이라고 한다. 48장, 49장에서 더 알아보자~

<br><br><br>

# 15장. let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 1. 변수 중복 선언 허용

var 키워드로 변수를 선언하게 되면 중복 선언도 가능하고 재할당도 가능하다. 이것이 많은 문제점을 불러 일으키기 때문에 요즘은 잘 사용하지 않는다고 한다..

### 2. 함수 레벨 스코프

함수 외부에서 var 키워드를 사용했지만 코드 블록 내에서 선언해도 모두 전역 변수가 된다고 함..!

```jsx
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); // 10
```

위 코드와 같은 대참사가 일어남..ㅎ

### 3. 변수 호이스팅

자바스크립트를 실행하면 var 키워드로 선언한 변수들이 먼저 동작 후 나머지 런타임 가짐..  
그래서 변수선언문 이전에 참조를 해도 에러가 발생하지 않음!

## 15.2~3 let, const 키워드

|                     | var 키워드          | let 키워드                        | const 키워드                      |
| ------------------- | ------------------- | --------------------------------- | --------------------------------- |
| 중복 선언           | 가능                | 불가능                            | 불가능                            |
| 재할당              | 가능                | 가능                              | 불가능                            |
| 선언 및 초기화 분리 | 가능                | 가능                              | 불가능                            |
| 지역 변수 인정      | only 함수 코드 블록 | 모든 코드 블록(=블록 레벨 스코프) | 모든 코드 블록(=블록 레벨 스코프) |
| 변수 호이스팅       | 발생                | 비발생                            | 비발생                            |
